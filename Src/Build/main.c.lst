                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.0.0 #11528 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _getUptimeSeconds
                                     13 	.globl _getUptimeTicks
                                     14 	.globl _getUptime
                                     15 	.globl _initTimer
                                     16 	.globl _initRelay
                                     17 	.globl _itofpa
                                     18 	.globl _paramToString
                                     19 	.globl _getParamById
                                     20 	.globl _getParamId
                                     21 	.globl _initParamsEEPROM
                                     22 	.globl _getMenuDisplay
                                     23 	.globl _initMenu
                                     24 	.globl _setDisplayTestMode
                                     25 	.globl _setDisplayStr
                                     26 	.globl _setDisplayOff
                                     27 	.globl _initDisplay
                                     28 	.globl _initButtons
                                     29 	.globl _getTemperature
                                     30 	.globl _getSensorFail
                                     31 	.globl _initADC
                                     32 ;--------------------------------------------------------
                                     33 ; ram data
                                     34 ;--------------------------------------------------------
                                     35 	.area DATA
      000000                         36 _main_stringBuffer_65536_16:
      000000                         37 	.ds 14
                                     38 ;--------------------------------------------------------
                                     39 ; ram data
                                     40 ;--------------------------------------------------------
                                     41 	.area INITIALIZED
                                     42 ;--------------------------------------------------------
                                     43 ; Stack segment in internal ram 
                                     44 ;--------------------------------------------------------
                                     45 	.area	SSEG
      000000                         46 __start__stack:
      000000                         47 	.ds	1
                                     48 
                                     49 ;--------------------------------------------------------
                                     50 ; absolute external ram data
                                     51 ;--------------------------------------------------------
                                     52 	.area DABS (ABS)
                                     53 
                                     54 ; default segment ordering for linker
                                     55 	.area HOME
                                     56 	.area GSINIT
                                     57 	.area GSFINAL
                                     58 	.area CONST
                                     59 	.area INITIALIZER
                                     60 	.area CODE
                                     61 
                                     62 ;--------------------------------------------------------
                                     63 ; interrupt vector 
                                     64 ;--------------------------------------------------------
                                     65 	.area HOME
      000000                         66 __interrupt_vect:
      000000 82v00u00u00             67 	int s_GSINIT ; reset
      000004 82 00 00 00             68 	int 0x000000 ; trap
      000008 82 00 00 00             69 	int 0x000000 ; int0
      00000C 82 00 00 00             70 	int 0x000000 ; int1
      000010 82 00 00 00             71 	int 0x000000 ; int2
      000014 82 00 00 00             72 	int 0x000000 ; int3
      000018 82 00 00 00             73 	int 0x000000 ; int4
      00001C 82v00u00u00             74 	int _EXTI2_handler ; int5
      000020 82 00 00 00             75 	int 0x000000 ; int6
      000024 82 00 00 00             76 	int 0x000000 ; int7
      000028 82 00 00 00             77 	int 0x000000 ; int8
      00002C 82 00 00 00             78 	int 0x000000 ; int9
      000030 82 00 00 00             79 	int 0x000000 ; int10
      000034 82 00 00 00             80 	int 0x000000 ; int11
      000038 82 00 00 00             81 	int 0x000000 ; int12
      00003C 82 00 00 00             82 	int 0x000000 ; int13
      000040 82 00 00 00             83 	int 0x000000 ; int14
      000044 82 00 00 00             84 	int 0x000000 ; int15
      000048 82 00 00 00             85 	int 0x000000 ; int16
      00004C 82 00 00 00             86 	int 0x000000 ; int17
      000050 82 00 00 00             87 	int 0x000000 ; int18
      000054 82 00 00 00             88 	int 0x000000 ; int19
      000058 82 00 00 00             89 	int 0x000000 ; int20
      00005C 82 00 00 00             90 	int 0x000000 ; int21
      000060 82v00u00u00             91 	int _ADC1_EOC_handler ; int22
      000064 82v00u00u00             92 	int _TIM4_UPD_handler ; int23
                                     93 ;--------------------------------------------------------
                                     94 ; global & static initialisations
                                     95 ;--------------------------------------------------------
                                     96 	.area HOME
                                     97 	.area GSINIT
                                     98 	.area GSFINAL
                                     99 	.area GSINIT
      000000                        100 __sdcc_gs_init_startup:
      000000                        101 __sdcc_init_data:
                                    102 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]  103 	ldw x, #l_DATA
      000003 27 07            [ 1]  104 	jreq	00002$
      000005                        105 00001$:
      000005 72 4FuFFuFF      [ 1]  106 	clr (s_DATA - 1, x)
      000009 5A               [ 2]  107 	decw x
      00000A 26 F9            [ 1]  108 	jrne	00001$
      00000C                        109 00002$:
      00000C AEr00r00         [ 2]  110 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]  111 	jreq	00004$
      000011                        112 00003$:
      000011 D6uFFuFF         [ 1]  113 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  114 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  115 	decw	x
      000018 26 F7            [ 1]  116 	jrne	00003$
      00001A                        117 00004$:
                                    118 ; stm8_genXINIT() end
                                    119 	.area GSFINAL
      000000 CCr00r68         [ 2]  120 	jp	__sdcc_program_startup
                                    121 ;--------------------------------------------------------
                                    122 ; Home
                                    123 ;--------------------------------------------------------
                                    124 	.area HOME
                                    125 	.area HOME
      000068                        126 __sdcc_program_startup:
      000068 CCr00r00         [ 2]  127 	jp	_main
                                    128 ;	return from main will return to caller
                                    129 ;--------------------------------------------------------
                                    130 ; code
                                    131 ;--------------------------------------------------------
                                    132 	.area CODE
                                    133 ;	./main.c: 34: int main()
                                    134 ;	-----------------------------------------
                                    135 ;	 function main
                                    136 ;	-----------------------------------------
      000000                        137 _main:
      000000 52 09            [ 2]  138 	sub	sp, #9
                                    139 ;	./main.c: 37: unsigned char paramMsg[] = {'P', '0', 0};
      000002 A6 50            [ 1]  140 	ld	a, #0x50
      000004 6B 01            [ 1]  141 	ld	(0x01, sp), a
      000006 96               [ 1]  142 	ldw	x, sp
      000007 1C 00 02         [ 2]  143 	addw	x, #2
      00000A 1F 04            [ 2]  144 	ldw	(0x04, sp), x
      00000C A6 30            [ 1]  145 	ld	a, #0x30
      00000E F7               [ 1]  146 	ld	(x), a
      00000F 96               [ 1]  147 	ldw	x, sp
      000010 1C 00 03         [ 2]  148 	addw	x, #3
      000013 7F               [ 1]  149 	clr	(x)
                                    150 ;	./main.c: 39: initMenu();
      000014 CDr00r00         [ 4]  151 	call	_initMenu
                                    152 ;	./main.c: 40: initButtons();
      000017 CDr00r00         [ 4]  153 	call	_initButtons
                                    154 ;	./main.c: 41: initParamsEEPROM();
      00001A CDr00r00         [ 4]  155 	call	_initParamsEEPROM
                                    156 ;	./main.c: 42: initDisplay();
      00001D CDr00r00         [ 4]  157 	call	_initDisplay
                                    158 ;	./main.c: 43: initADC();
      000020 CDr00r00         [ 4]  159 	call	_initADC
                                    160 ;	./main.c: 44: initRelay();
      000023 CDr00r00         [ 4]  161 	call	_initRelay
                                    162 ;	./main.c: 45: initTimer();
      000026 CDr00r00         [ 4]  163 	call	_initTimer
                                    164 ;	./main.c: 47: INTERRUPT_ENABLE
      000029 9A               [ 1]  165 	rim	
                                    166 ;	./main.c: 50: while (true) {
      00002A                        167 00150$:
                                    168 ;	./main.c: 51: if (getUptimeSeconds() > 0) {
      00002A CDr00r00         [ 4]  169 	call	_getUptimeSeconds
      00002D 4D               [ 1]  170 	tnz	a
      00002E 27 0B            [ 1]  171 	jreq	00102$
                                    172 ;	./main.c: 52: setDisplayTestMode (false, "");
      000030 4Br00            [ 1]  173 	push	#<(___str_0 + 0)
      000032 4Bs00            [ 1]  174 	push	#((___str_0 + 0) >> 8)
      000034 4B 00            [ 1]  175 	push	#0x00
      000036 CDr00r00         [ 4]  176 	call	_setDisplayTestMode
      000039 5B 03            [ 2]  177 	addw	sp, #3
      00003B                        178 00102$:
                                    179 ;	./main.c: 55: if (getMenuDisplay() == MENU_ROOT) {
      00003B CDr00r00         [ 4]  180 	call	_getMenuDisplay
      00003E 6B 09            [ 1]  181 	ld	(0x09, sp), a
      000040 27 03            [ 1]  182 	jreq	00245$
      000042 CCr00rF1         [ 2]  183 	jp	00147$
      000045                        184 00245$:
                                    185 ;	./main.c: 56: int temp = getTemperature();
      000045 CDr00r00         [ 4]  186 	call	_getTemperature
      000048 1F 06            [ 2]  187 	ldw	(0x06, sp), x
                                    188 ;	./main.c: 57: int sensor_fail = getSensorFail();
      00004A CDr00r00         [ 4]  189 	call	_getSensorFail
                                    190 ;	./main.c: 59: if(sensor_fail > 0) {
      00004D A3 00 00         [ 2]  191 	cpw	x, #0x0000
      000050 2D 30            [ 1]  192 	jrsle	00114$
                                    193 ;	./main.c: 60: bool blink = (bool) ( (unsigned char) getUptimeTicks() & 0x40);
      000052 89               [ 2]  194 	pushw	x
      000053 CDr00r00         [ 4]  195 	call	_getUptimeTicks
      000056 1F 0A            [ 2]  196 	ldw	(0x0a, sp), x
      000058 85               [ 2]  197 	popw	x
      000059 7B 09            [ 1]  198 	ld	a, (0x09, sp)
      00005B 48               [ 1]  199 	sll	a
      00005C 48               [ 1]  200 	sll	a
      00005D 4F               [ 1]  201 	clr	a
      00005E 49               [ 1]  202 	rlc	a
      00005F 6B 09            [ 1]  203 	ld	(0x09, sp), a
                                    204 ;	./main.c: 62: if(sensor_fail == 1) {
      000061 5A               [ 2]  205 	decw	x
      000062 26 0B            [ 1]  206 	jrne	00104$
                                    207 ;	./main.c: 63: setDisplayStr ("HHH");
      000064 4Br01            [ 1]  208 	push	#<(___str_1 + 0)
      000066 4Bs00            [ 1]  209 	push	#((___str_1 + 0) >> 8)
      000068 CDr00r00         [ 4]  210 	call	_setDisplayStr
      00006B 5B 02            [ 2]  211 	addw	sp, #2
      00006D 20 09            [ 2]  212 	jra	00105$
      00006F                        213 00104$:
                                    214 ;	./main.c: 65: setDisplayStr ("LLL");
      00006F 4Br05            [ 1]  215 	push	#<(___str_2 + 0)
      000071 4Bs00            [ 1]  216 	push	#((___str_2 + 0) >> 8)
      000073 CDr00r00         [ 4]  217 	call	_setDisplayStr
      000076 5B 02            [ 2]  218 	addw	sp, #2
      000078                        219 00105$:
                                    220 ;	./main.c: 68: setDisplayOff (blink);
      000078 7B 09            [ 1]  221 	ld	a, (0x09, sp)
      00007A 88               [ 1]  222 	push	a
      00007B CDr00r00         [ 4]  223 	call	_setDisplayOff
      00007E 84               [ 1]  224 	pop	a
      00007F CCr02r40         [ 2]  225 	jp	00148$
      000082                        226 00114$:
                                    227 ;	./main.c: 70: itofpa (temp, (char*) stringBuffer, 0);
      000082 AEr00r00         [ 2]  228 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      000085 4B 00            [ 1]  229 	push	#0x00
      000087 89               [ 2]  230 	pushw	x
      000088 1E 09            [ 2]  231 	ldw	x, (0x09, sp)
      00008A 89               [ 2]  232 	pushw	x
      00008B CDr00r00         [ 4]  233 	call	_itofpa
      00008E 5B 05            [ 2]  234 	addw	sp, #5
                                    235 ;	./main.c: 71: setDisplayStr ( (char*) stringBuffer);
      000090 AEr00r00         [ 2]  236 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      000093 89               [ 2]  237 	pushw	x
      000094 CDr00r00         [ 4]  238 	call	_setDisplayStr
      000097 5B 02            [ 2]  239 	addw	sp, #2
                                    240 ;	./main.c: 73: if (getParamById (PARAM_OVERHEAT_INDICATION) ) {
      000099 4B 06            [ 1]  241 	push	#0x06
      00009B CDr00r00         [ 4]  242 	call	_getParamById
      00009E 84               [ 1]  243 	pop	a
      00009F 5D               [ 2]  244 	tnzw	x
      0000A0 26 03            [ 1]  245 	jrne	00250$
      0000A2 CCr02r40         [ 2]  246 	jp	00148$
      0000A5                        247 00250$:
                                    248 ;	./main.c: 74: bool blink = (bool) ( (unsigned char) getUptimeTicks() & 0x80);
      0000A5 CDr00r00         [ 4]  249 	call	_getUptimeTicks
      0000A8 9F               [ 1]  250 	ld	a, xl
      0000A9 48               [ 1]  251 	sll	a
      0000AA 4F               [ 1]  252 	clr	a
      0000AB 49               [ 1]  253 	rlc	a
                                    254 ;	./main.c: 76: if (temp < (getParamById (PARAM_MIN_TEMPERATURE) * 10) ) {
      0000AC 88               [ 1]  255 	push	a
      0000AD 4B 03            [ 1]  256 	push	#0x03
      0000AF CDr00r00         [ 4]  257 	call	_getParamById
      0000B2 84               [ 1]  258 	pop	a
      0000B3 84               [ 1]  259 	pop	a
      0000B4 89               [ 2]  260 	pushw	x
      0000B5 58               [ 2]  261 	sllw	x
      0000B6 58               [ 2]  262 	sllw	x
      0000B7 72 FB 01         [ 2]  263 	addw	x, (1, sp)
      0000BA 58               [ 2]  264 	sllw	x
      0000BB 5B 02            [ 2]  265 	addw	sp, #2
      0000BD 1F 08            [ 2]  266 	ldw	(0x08, sp), x
      0000BF 1E 06            [ 2]  267 	ldw	x, (0x06, sp)
      0000C1 13 08            [ 2]  268 	cpw	x, (0x08, sp)
      0000C3 2E 08            [ 1]  269 	jrsge	00109$
                                    270 ;	./main.c: 77: setDisplayOff (blink);
      0000C5 88               [ 1]  271 	push	a
      0000C6 CDr00r00         [ 4]  272 	call	_setDisplayOff
      0000C9 84               [ 1]  273 	pop	a
      0000CA CCr02r40         [ 2]  274 	jp	00148$
      0000CD                        275 00109$:
                                    276 ;	./main.c: 78: } else if (temp >= (getParamById (PARAM_MAX_TEMPERATURE) * 10) ) {
      0000CD 88               [ 1]  277 	push	a
      0000CE 4B 02            [ 1]  278 	push	#0x02
      0000D0 CDr00r00         [ 4]  279 	call	_getParamById
      0000D3 84               [ 1]  280 	pop	a
      0000D4 84               [ 1]  281 	pop	a
      0000D5 89               [ 2]  282 	pushw	x
      0000D6 58               [ 2]  283 	sllw	x
      0000D7 58               [ 2]  284 	sllw	x
      0000D8 72 FB 01         [ 2]  285 	addw	x, (1, sp)
      0000DB 58               [ 2]  286 	sllw	x
      0000DC 5B 02            [ 2]  287 	addw	sp, #2
      0000DE 1F 08            [ 2]  288 	ldw	(0x08, sp), x
      0000E0 1E 06            [ 2]  289 	ldw	x, (0x06, sp)
      0000E2 13 08            [ 2]  290 	cpw	x, (0x08, sp)
      0000E4 2E 03            [ 1]  291 	jrsge	00252$
      0000E6 CCr02r40         [ 2]  292 	jp	00148$
      0000E9                        293 00252$:
                                    294 ;	./main.c: 79: setDisplayOff (blink);
      0000E9 88               [ 1]  295 	push	a
      0000EA CDr00r00         [ 4]  296 	call	_setDisplayOff
      0000ED 84               [ 1]  297 	pop	a
      0000EE CCr02r40         [ 2]  298 	jp	00148$
      0000F1                        299 00147$:
                                    300 ;	./main.c: 83: } else if (getMenuDisplay() == MENU_SET_THRESHOLD) {
      0000F1 CDr00r00         [ 4]  301 	call	_getMenuDisplay
      0000F4 4A               [ 1]  302 	dec	a
      0000F5 26 17            [ 1]  303 	jrne	00144$
                                    304 ;	./main.c: 84: paramToString (PARAM_THRESHOLD, (char*) stringBuffer);
      0000F7 AEr00r00         [ 2]  305 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      0000FA 89               [ 2]  306 	pushw	x
      0000FB 4B 09            [ 1]  307 	push	#0x09
      0000FD CDr00r00         [ 4]  308 	call	_paramToString
      000100 5B 03            [ 2]  309 	addw	sp, #3
                                    310 ;	./main.c: 85: setDisplayStr ( (char*) stringBuffer);
      000102 AEr00r00         [ 2]  311 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      000105 89               [ 2]  312 	pushw	x
      000106 CDr00r00         [ 4]  313 	call	_setDisplayStr
      000109 5B 02            [ 2]  314 	addw	sp, #2
      00010B CCr02r40         [ 2]  315 	jp	00148$
      00010E                        316 00144$:
                                    317 ;	./main.c: 86: } else if (getMenuDisplay() == MENU_SELECT_PARAM) {
      00010E CDr00r00         [ 4]  318 	call	_getMenuDisplay
      000111 A1 02            [ 1]  319 	cp	a, #0x02
      000113 26 13            [ 1]  320 	jrne	00141$
                                    321 ;	./main.c: 87: paramMsg[1] = '0' + getParamId();
      000115 CDr00r00         [ 4]  322 	call	_getParamId
      000118 AB 30            [ 1]  323 	add	a, #0x30
      00011A 1E 04            [ 2]  324 	ldw	x, (0x04, sp)
      00011C F7               [ 1]  325 	ld	(x), a
                                    326 ;	./main.c: 88: setDisplayStr ( (unsigned char*) &paramMsg);
      00011D 96               [ 1]  327 	ldw	x, sp
      00011E 5C               [ 1]  328 	incw	x
      00011F 89               [ 2]  329 	pushw	x
      000120 CDr00r00         [ 4]  330 	call	_setDisplayStr
      000123 5B 02            [ 2]  331 	addw	sp, #2
      000125 CCr02r40         [ 2]  332 	jp	00148$
      000128                        333 00141$:
                                    334 ;	./main.c: 89: } else if (getMenuDisplay() == MENU_CHANGE_PARAM) {
      000128 CDr00r00         [ 4]  335 	call	_getMenuDisplay
      00012B A1 03            [ 1]  336 	cp	a, #0x03
      00012D 26 19            [ 1]  337 	jrne	00138$
                                    338 ;	./main.c: 90: paramToString (getParamId(), (char*) stringBuffer);
      00012F AEr00r00         [ 2]  339 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      000132 89               [ 2]  340 	pushw	x
      000133 CDr00r00         [ 4]  341 	call	_getParamId
      000136 88               [ 1]  342 	push	a
      000137 CDr00r00         [ 4]  343 	call	_paramToString
      00013A 5B 03            [ 2]  344 	addw	sp, #3
                                    345 ;	./main.c: 91: setDisplayStr ( (char *) stringBuffer);
      00013C AEr00r00         [ 2]  346 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      00013F 89               [ 2]  347 	pushw	x
      000140 CDr00r00         [ 4]  348 	call	_setDisplayStr
      000143 5B 02            [ 2]  349 	addw	sp, #2
      000145 CCr02r40         [ 2]  350 	jp	00148$
      000148                        351 00138$:
                                    352 ;	./main.c: 92: } else if (getMenuDisplay() == MENU_ALARM) {
      000148 CDr00r00         [ 4]  353 	call	_getMenuDisplay
      00014B A1 04            [ 1]  354 	cp	a, #0x04
      00014D 26 2E            [ 1]  355 	jrne	00135$
                                    356 ;	./main.c: 93: if(getParamById(PARAM_RELAY_MODE) == 2) {
      00014F 4B 00            [ 1]  357 	push	#0x00
      000151 CDr00r00         [ 4]  358 	call	_getParamById
      000154 84               [ 1]  359 	pop	a
      000155 A3 00 02         [ 2]  360 	cpw	x, #0x0002
      000158 26 0B            [ 1]  361 	jrne	00117$
                                    362 ;	./main.c: 94: setDisplayStr ("AL1");
      00015A 4Br09            [ 1]  363 	push	#<(___str_3 + 0)
      00015C 4Bs00            [ 1]  364 	push	#((___str_3 + 0) >> 8)
      00015E CDr00r00         [ 4]  365 	call	_setDisplayStr
      000161 5B 02            [ 2]  366 	addw	sp, #2
      000163 20 09            [ 2]  367 	jra	00118$
      000165                        368 00117$:
                                    369 ;	./main.c: 96: setDisplayStr ("AL2");
      000165 4Br0D            [ 1]  370 	push	#<(___str_4 + 0)
      000167 4Bs00            [ 1]  371 	push	#((___str_4 + 0) >> 8)
      000169 CDr00r00         [ 4]  372 	call	_setDisplayStr
      00016C 5B 02            [ 2]  373 	addw	sp, #2
      00016E                        374 00118$:
                                    375 ;	./main.c: 98: setDisplayOff ( (bool) (getUptime() & 0x80) );
      00016E CDr00r00         [ 4]  376 	call	_getUptime
      000171 9F               [ 1]  377 	ld	a, xl
      000172 48               [ 1]  378 	sll	a
      000173 4F               [ 1]  379 	clr	a
      000174 49               [ 1]  380 	rlc	a
      000175 88               [ 1]  381 	push	a
      000176 CDr00r00         [ 4]  382 	call	_setDisplayOff
      000179 84               [ 1]  383 	pop	a
      00017A CCr02r40         [ 2]  384 	jp	00148$
      00017D                        385 00135$:
                                    386 ;	./main.c: 99: } else if (getMenuDisplay() == MENU_ALARM_HIGH) {
      00017D CDr00r00         [ 4]  387 	call	_getMenuDisplay
      000180 A1 05            [ 1]  388 	cp	a, #0x05
      000182 26 35            [ 1]  389 	jrne	00132$
                                    390 ;	./main.c: 100: int temp = getParamById (PARAM_MAX_TEMPERATURE) * 10;
      000184 4B 02            [ 1]  391 	push	#0x02
      000186 CDr00r00         [ 4]  392 	call	_getParamById
      000189 84               [ 1]  393 	pop	a
      00018A 89               [ 2]  394 	pushw	x
      00018B 58               [ 2]  395 	sllw	x
      00018C 58               [ 2]  396 	sllw	x
      00018D 72 FB 01         [ 2]  397 	addw	x, (1, sp)
      000190 58               [ 2]  398 	sllw	x
      000191 5B 02            [ 2]  399 	addw	sp, #2
                                    400 ;	./main.c: 101: itofpa (temp, (char*) stringBuffer, 0);
      000193 90 AEr00r00      [ 2]  401 	ldw	y, #(_main_stringBuffer_65536_16 + 0)
      000197 4B 00            [ 1]  402 	push	#0x00
      000199 90 89            [ 2]  403 	pushw	y
      00019B 89               [ 2]  404 	pushw	x
      00019C CDr00r00         [ 4]  405 	call	_itofpa
      00019F 5B 05            [ 2]  406 	addw	sp, #5
                                    407 ;	./main.c: 102: setDisplayStr ( (char*) stringBuffer);
      0001A1 AEr00r00         [ 2]  408 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      0001A4 89               [ 2]  409 	pushw	x
      0001A5 CDr00r00         [ 4]  410 	call	_setDisplayStr
      0001A8 5B 02            [ 2]  411 	addw	sp, #2
                                    412 ;	./main.c: 103: setDisplayOff ( (bool) (getUptime() & 0x80) );
      0001AA CDr00r00         [ 4]  413 	call	_getUptime
      0001AD 9F               [ 1]  414 	ld	a, xl
      0001AE 48               [ 1]  415 	sll	a
      0001AF 4F               [ 1]  416 	clr	a
      0001B0 49               [ 1]  417 	rlc	a
      0001B1 88               [ 1]  418 	push	a
      0001B2 CDr00r00         [ 4]  419 	call	_setDisplayOff
      0001B5 84               [ 1]  420 	pop	a
      0001B6 CCr02r40         [ 2]  421 	jp	00148$
      0001B9                        422 00132$:
                                    423 ;	./main.c: 104: } else if (getMenuDisplay() == MENU_ALARM_LOW) {
      0001B9 CDr00r00         [ 4]  424 	call	_getMenuDisplay
      0001BC A1 06            [ 1]  425 	cp	a, #0x06
      0001BE 26 34            [ 1]  426 	jrne	00129$
                                    427 ;	./main.c: 105: int temp = getParamById (PARAM_MIN_TEMPERATURE) * 10;
      0001C0 4B 03            [ 1]  428 	push	#0x03
      0001C2 CDr00r00         [ 4]  429 	call	_getParamById
      0001C5 84               [ 1]  430 	pop	a
      0001C6 89               [ 2]  431 	pushw	x
      0001C7 58               [ 2]  432 	sllw	x
      0001C8 58               [ 2]  433 	sllw	x
      0001C9 72 FB 01         [ 2]  434 	addw	x, (1, sp)
      0001CC 58               [ 2]  435 	sllw	x
      0001CD 5B 02            [ 2]  436 	addw	sp, #2
                                    437 ;	./main.c: 106: itofpa (temp, (char*) stringBuffer, 0);
      0001CF 90 AEr00r00      [ 2]  438 	ldw	y, #(_main_stringBuffer_65536_16 + 0)
      0001D3 4B 00            [ 1]  439 	push	#0x00
      0001D5 90 89            [ 2]  440 	pushw	y
      0001D7 89               [ 2]  441 	pushw	x
      0001D8 CDr00r00         [ 4]  442 	call	_itofpa
      0001DB 5B 05            [ 2]  443 	addw	sp, #5
                                    444 ;	./main.c: 107: setDisplayStr ( (char*) stringBuffer);
      0001DD AEr00r00         [ 2]  445 	ldw	x, #(_main_stringBuffer_65536_16 + 0)
      0001E0 89               [ 2]  446 	pushw	x
      0001E1 CDr00r00         [ 4]  447 	call	_setDisplayStr
      0001E4 5B 02            [ 2]  448 	addw	sp, #2
                                    449 ;	./main.c: 108: setDisplayOff ( (bool) (getUptime() & 0x80) );
      0001E6 CDr00r00         [ 4]  450 	call	_getUptime
      0001E9 9F               [ 1]  451 	ld	a, xl
      0001EA 48               [ 1]  452 	sll	a
      0001EB 4F               [ 1]  453 	clr	a
      0001EC 49               [ 1]  454 	rlc	a
      0001ED 88               [ 1]  455 	push	a
      0001EE CDr00r00         [ 4]  456 	call	_setDisplayOff
      0001F1 84               [ 1]  457 	pop	a
      0001F2 20 4C            [ 2]  458 	jra	00148$
      0001F4                        459 00129$:
                                    460 ;	./main.c: 110: if(getMenuDisplay() == MENU_EEPROM_RESET) {
      0001F4 CDr00r00         [ 4]  461 	call	_getMenuDisplay
      0001F7 A1 07            [ 1]  462 	cp	a, #0x07
      0001F9 26 0B            [ 1]  463 	jrne	00126$
                                    464 ;	./main.c: 111: setDisplayStr ("RST");
      0001FB 4Br11            [ 1]  465 	push	#<(___str_5 + 0)
      0001FD 4Bs00            [ 1]  466 	push	#((___str_5 + 0) >> 8)
      0001FF CDr00r00         [ 4]  467 	call	_setDisplayStr
      000202 5B 02            [ 2]  468 	addw	sp, #2
      000204 20 3A            [ 2]  469 	jra	00148$
      000206                        470 00126$:
                                    471 ;	./main.c: 112: } else if(getMenuDisplay() == MENU_EEPROM_LOCKED) {
      000206 CDr00r00         [ 4]  472 	call	_getMenuDisplay
      000209 A1 08            [ 1]  473 	cp	a, #0x08
      00020B 26 0B            [ 1]  474 	jrne	00123$
                                    475 ;	./main.c: 113: setDisplayStr (" P7");
      00020D 4Br15            [ 1]  476 	push	#<(___str_6 + 0)
      00020F 4Bs00            [ 1]  477 	push	#((___str_6 + 0) >> 8)
      000211 CDr00r00         [ 4]  478 	call	_setDisplayStr
      000214 5B 02            [ 2]  479 	addw	sp, #2
      000216 20 28            [ 2]  480 	jra	00148$
      000218                        481 00123$:
                                    482 ;	./main.c: 114: } else if(getMenuDisplay() == MENU_EEPROM_LOC_2) {
      000218 CDr00r00         [ 4]  483 	call	_getMenuDisplay
      00021B A1 09            [ 1]  484 	cp	a, #0x09
      00021D 26 0B            [ 1]  485 	jrne	00120$
                                    486 ;	./main.c: 115: setDisplayStr ("LOC");
      00021F 4Br19            [ 1]  487 	push	#<(___str_7 + 0)
      000221 4Bs00            [ 1]  488 	push	#((___str_7 + 0) >> 8)
      000223 CDr00r00         [ 4]  489 	call	_setDisplayStr
      000226 5B 02            [ 2]  490 	addw	sp, #2
      000228 20 16            [ 2]  491 	jra	00148$
      00022A                        492 00120$:
                                    493 ;	./main.c: 117: setDisplayStr ("ERR");
      00022A 4Br1D            [ 1]  494 	push	#<(___str_8 + 0)
      00022C 4Bs00            [ 1]  495 	push	#((___str_8 + 0) >> 8)
      00022E CDr00r00         [ 4]  496 	call	_setDisplayStr
      000231 5B 02            [ 2]  497 	addw	sp, #2
                                    498 ;	./main.c: 118: setDisplayOff ( (bool) (getUptime() & 0x40) );
      000233 CDr00r00         [ 4]  499 	call	_getUptime
      000236 9F               [ 1]  500 	ld	a, xl
      000237 48               [ 1]  501 	sll	a
      000238 48               [ 1]  502 	sll	a
      000239 4F               [ 1]  503 	clr	a
      00023A 49               [ 1]  504 	rlc	a
      00023B 88               [ 1]  505 	push	a
      00023C CDr00r00         [ 4]  506 	call	_setDisplayOff
      00023F 84               [ 1]  507 	pop	a
      000240                        508 00148$:
                                    509 ;	./main.c: 122: WAIT_FOR_INTERRUPT
      000240 8F               [10]  510 	wfi	
                                    511 ;	./main.c: 124: }
      000241 CCr00r2A         [ 2]  512 	jp	00150$
                                    513 	.area CODE
                                    514 	.area CONST
                                    515 	.area CONST
      000000                        516 ___str_0:
      000000 00                     517 	.db 0x00
                                    518 	.area CODE
                                    519 	.area CONST
      000001                        520 ___str_1:
      000001 48 48 48               521 	.ascii "HHH"
      000004 00                     522 	.db 0x00
                                    523 	.area CODE
                                    524 	.area CONST
      000005                        525 ___str_2:
      000005 4C 4C 4C               526 	.ascii "LLL"
      000008 00                     527 	.db 0x00
                                    528 	.area CODE
                                    529 	.area CONST
      000009                        530 ___str_3:
      000009 41 4C 31               531 	.ascii "AL1"
      00000C 00                     532 	.db 0x00
                                    533 	.area CODE
                                    534 	.area CONST
      00000D                        535 ___str_4:
      00000D 41 4C 32               536 	.ascii "AL2"
      000010 00                     537 	.db 0x00
                                    538 	.area CODE
                                    539 	.area CONST
      000011                        540 ___str_5:
      000011 52 53 54               541 	.ascii "RST"
      000014 00                     542 	.db 0x00
                                    543 	.area CODE
                                    544 	.area CONST
      000015                        545 ___str_6:
      000015 20 50 37               546 	.ascii " P7"
      000018 00                     547 	.db 0x00
                                    548 	.area CODE
                                    549 	.area CONST
      000019                        550 ___str_7:
      000019 4C 4F 43               551 	.ascii "LOC"
      00001C 00                     552 	.db 0x00
                                    553 	.area CODE
                                    554 	.area CONST
      00001D                        555 ___str_8:
      00001D 45 52 52               556 	.ascii "ERR"
      000020 00                     557 	.db 0x00
                                    558 	.area CODE
                                    559 	.area INITIALIZER
                                    560 	.area CABS (ABS)
