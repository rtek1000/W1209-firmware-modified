                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.0.0 #11528 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module timer
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _refreshRelay
                                     12 	.globl _refreshMenu
                                     13 	.globl _refreshDisplay
                                     14 	.globl _startADC
                                     15 	.globl _initTimer
                                     16 	.globl _resetUptime
                                     17 	.globl _getUptime
                                     18 	.globl _getUptimeTicks
                                     19 	.globl _getUptimeSeconds
                                     20 	.globl _getUptimeMinutes
                                     21 	.globl _getUptimeHours
                                     22 	.globl _getUptimeDays
                                     23 	.globl _TIM4_UPD_handler
                                     24 ;--------------------------------------------------------
                                     25 ; ram data
                                     26 ;--------------------------------------------------------
                                     27 	.area DATA
      000000                         28 _uptime:
      000000                         29 	.ds 4
                                     30 ;--------------------------------------------------------
                                     31 ; ram data
                                     32 ;--------------------------------------------------------
                                     33 	.area INITIALIZED
                                     34 ;--------------------------------------------------------
                                     35 ; absolute external ram data
                                     36 ;--------------------------------------------------------
                                     37 	.area DABS (ABS)
                                     38 
                                     39 ; default segment ordering for linker
                                     40 	.area HOME
                                     41 	.area GSINIT
                                     42 	.area GSFINAL
                                     43 	.area CONST
                                     44 	.area INITIALIZER
                                     45 	.area CODE
                                     46 
                                     47 ;--------------------------------------------------------
                                     48 ; global & static initialisations
                                     49 ;--------------------------------------------------------
                                     50 	.area HOME
                                     51 	.area GSINIT
                                     52 	.area GSFINAL
                                     53 	.area GSINIT
                                     54 ;--------------------------------------------------------
                                     55 ; Home
                                     56 ;--------------------------------------------------------
                                     57 	.area HOME
                                     58 	.area HOME
                                     59 ;--------------------------------------------------------
                                     60 ; code
                                     61 ;--------------------------------------------------------
                                     62 	.area CODE
                                     63 ;	./timer.c: 54: void initTimer()
                                     64 ;	-----------------------------------------
                                     65 ;	 function initTimer
                                     66 ;	-----------------------------------------
      000000                         67 _initTimer:
                                     68 ;	./timer.c: 56: CLK_CKDIVR = 0x00;  // Set the frequency to 16 MHz
      000000 35 00 50 C6      [ 1]   69 	mov	0x50c6+0, #0x00
                                     70 ;	./timer.c: 57: TIM4_PSCR = 0x07;   // CLK / 128 = 125KHz
      000004 35 07 53 47      [ 1]   71 	mov	0x5347+0, #0x07
                                     72 ;	./timer.c: 58: TIM4_ARR = 0xFA;    // 125KHz /  250(0xFA) = 500Hz
      000008 35 FA 53 48      [ 1]   73 	mov	0x5348+0, #0xfa
                                     74 ;	./timer.c: 59: TIM4_IER = 0x01;    // Enable interrupt on update event
      00000C 35 01 53 43      [ 1]   75 	mov	0x5343+0, #0x01
                                     76 ;	./timer.c: 60: TIM4_CR1 = 0x05;    // Enable timer
      000010 35 05 53 40      [ 1]   77 	mov	0x5340+0, #0x05
                                     78 ;	./timer.c: 61: resetUptime();
                                     79 ;	./timer.c: 62: }
      000014 CCr00r17         [ 2]   80 	jp	_resetUptime
                                     81 ;	./timer.c: 67: void resetUptime()
                                     82 ;	-----------------------------------------
                                     83 ;	 function resetUptime
                                     84 ;	-----------------------------------------
      000017                         85 _resetUptime:
                                     86 ;	./timer.c: 69: uptime = 0;
      000017 5F               [ 1]   87 	clrw	x
      000018 CFu00u02         [ 2]   88 	ldw	_uptime+2, x
      00001B CFu00u00         [ 2]   89 	ldw	_uptime+0, x
                                     90 ;	./timer.c: 70: }
      00001E 81               [ 4]   91 	ret
                                     92 ;	./timer.c: 78: unsigned long getUptime()
                                     93 ;	-----------------------------------------
                                     94 ;	 function getUptime
                                     95 ;	-----------------------------------------
      00001F                         96 _getUptime:
                                     97 ;	./timer.c: 80: return uptime;
      00001F CEu00u02         [ 2]   98 	ldw	x, _uptime+2
      000022 90 CEu00u00      [ 2]   99 	ldw	y, _uptime+0
                                    100 ;	./timer.c: 81: }
      000026 81               [ 4]  101 	ret
                                    102 ;	./timer.c: 87: unsigned int getUptimeTicks()
                                    103 ;	-----------------------------------------
                                    104 ;	 function getUptimeTicks
                                    105 ;	-----------------------------------------
      000027                        106 _getUptimeTicks:
                                    107 ;	./timer.c: 89: return (unsigned int) (uptime & BITMASK (BITS_FOR_TICKS) );
      000027 CEu00u02         [ 2]  108 	ldw	x, _uptime+2
      00002A 9E               [ 1]  109 	ld	a, xh
      00002B A4 01            [ 1]  110 	and	a, #0x01
      00002D 95               [ 1]  111 	ld	xh, a
                                    112 ;	./timer.c: 90: }
      00002E 81               [ 4]  113 	ret
                                    114 ;	./timer.c: 96: unsigned char getUptimeSeconds()
                                    115 ;	-----------------------------------------
                                    116 ;	 function getUptimeSeconds
                                    117 ;	-----------------------------------------
      00002F                        118 _getUptimeSeconds:
      00002F 52 04            [ 2]  119 	sub	sp, #4
                                    120 ;	./timer.c: 98: return (unsigned char) ( (uptime >> SECONDS_FIRST_BIT) & BITMASK (BITS_FOR_SECONDS) );
      000031 C6u00u02         [ 1]  121 	ld	a, _uptime+2
      000034 CEu00u00         [ 2]  122 	ldw	x, _uptime+0
      000037 0F 01            [ 1]  123 	clr	(0x01, sp)
      000039 54               [ 2]  124 	srlw	x
      00003A 46               [ 1]  125 	rrc	a
      00003B 54               [ 2]  126 	srlw	x
      00003C 46               [ 1]  127 	rrc	a
      00003D A4 3F            [ 1]  128 	and	a, #0x3f
                                    129 ;	./timer.c: 99: }
      00003F 5B 04            [ 2]  130 	addw	sp, #4
      000041 81               [ 4]  131 	ret
                                    132 ;	./timer.c: 105: unsigned char getUptimeMinutes()
                                    133 ;	-----------------------------------------
                                    134 ;	 function getUptimeMinutes
                                    135 ;	-----------------------------------------
      000042                        136 _getUptimeMinutes:
                                    137 ;	./timer.c: 107: return (unsigned char) ( (uptime >> MINUTES_FIRST_BIT) & BITMASK (BITS_FOR_MINUTES) );
      000042 CEu00u00         [ 2]  138 	ldw	x, _uptime+0
      000045 9F               [ 1]  139 	ld	a, xl
      000046 A4 3F            [ 1]  140 	and	a, #0x3f
                                    141 ;	./timer.c: 108: }
      000048 81               [ 4]  142 	ret
                                    143 ;	./timer.c: 114: unsigned char getUptimeHours()
                                    144 ;	-----------------------------------------
                                    145 ;	 function getUptimeHours
                                    146 ;	-----------------------------------------
      000049                        147 _getUptimeHours:
                                    148 ;	./timer.c: 116: return (unsigned char) ( (uptime >> HOURS_FIRST_BIT) & BITMASK (BITS_FOR_HOURS) );
      000049 CEu00u00         [ 2]  149 	ldw	x, _uptime+0
      00004C A6 40            [ 1]  150 	ld	a, #0x40
      00004E 62               [ 2]  151 	div	x, a
      00004F 9F               [ 1]  152 	ld	a, xl
      000050 A4 1F            [ 1]  153 	and	a, #0x1f
                                    154 ;	./timer.c: 117: }
      000052 81               [ 4]  155 	ret
                                    156 ;	./timer.c: 123: unsigned char getUptimeDays()
                                    157 ;	-----------------------------------------
                                    158 ;	 function getUptimeDays
                                    159 ;	-----------------------------------------
      000053                        160 _getUptimeDays:
      000053 52 04            [ 2]  161 	sub	sp, #4
                                    162 ;	./timer.c: 125: return (unsigned char) ( (uptime >> DAYS_FIRST_BIT) & BITMASK (BITS_FOR_DAYS) );
      000055 C6u00u00         [ 1]  163 	ld	a, _uptime+0
      000058 0F 01            [ 1]  164 	clr	(0x01, sp)
      00005A 44               [ 1]  165 	srl	a
      00005B 44               [ 1]  166 	srl	a
      00005C 44               [ 1]  167 	srl	a
      00005D A4 3F            [ 1]  168 	and	a, #0x3f
                                    169 ;	./timer.c: 126: }
      00005F 5B 04            [ 2]  170 	addw	sp, #4
      000061 81               [ 4]  171 	ret
                                    172 ;	./timer.c: 132: void TIM4_UPD_handler() __interrupt (23)
                                    173 ;	-----------------------------------------
                                    174 ;	 function TIM4_UPD_handler
                                    175 ;	-----------------------------------------
      000062                        176 _TIM4_UPD_handler:
      000062 4F               [ 1]  177 	clr	a
      000063 62               [ 2]  178 	div	x, a
                                    179 ;	./timer.c: 134: TIM4_SR &= ~TIM_SR1_UIF; // Reset flag
      000064 72 11 53 44      [ 1]  180 	bres	21316, #0
                                    181 ;	./timer.c: 136: if ( ( (unsigned int) (uptime & BITMASK (BITS_FOR_TICKS) ) ) >= TICKS_IN_SECOND) {
      000068 CEu00u02         [ 2]  182 	ldw	x, _uptime+2
      00006B 9E               [ 1]  183 	ld	a, xh
      00006C A4 01            [ 1]  184 	and	a, #0x01
      00006E 95               [ 1]  185 	ld	xh, a
      00006F A3 01 F4         [ 2]  186 	cpw	x, #0x01f4
      000072 24 03            [ 1]  187 	jrnc	00154$
      000074 CCr01r41         [ 2]  188 	jp	00108$
      000077                        189 00154$:
                                    190 ;	./timer.c: 137: uptime &= NBITMASK (SECONDS_FIRST_BIT);
      000077 4F               [ 1]  191 	clr	a
      000078 97               [ 1]  192 	ld	xl, a
      000079 C6u00u02         [ 1]  193 	ld	a, _uptime+2
      00007C A4 FC            [ 1]  194 	and	a, #0xfc
      00007E 95               [ 1]  195 	ld	xh, a
      00007F 90 CEu00u00      [ 2]  196 	ldw	y, _uptime+0
      000083 CFu00u02         [ 2]  197 	ldw	_uptime+2, x
      000086 90 CFu00u00      [ 2]  198 	ldw	_uptime+0, y
                                    199 ;	./timer.c: 138: uptime += (unsigned long) 1 << SECONDS_FIRST_BIT;
      00008A CEu00u02         [ 2]  200 	ldw	x, _uptime+2
      00008D 1C 04 00         [ 2]  201 	addw	x, #0x0400
      000090 90 CEu00u00      [ 2]  202 	ldw	y, _uptime+0
      000094 24 02            [ 1]  203 	jrnc	00155$
      000096 90 5C            [ 1]  204 	incw	y
      000098                        205 00155$:
      000098 CFu00u02         [ 2]  206 	ldw	_uptime+2, x
      00009B 90 CFu00u00      [ 2]  207 	ldw	_uptime+0, y
                                    208 ;	./timer.c: 141: if ( ( (unsigned char) (uptime >> SECONDS_FIRST_BIT) & BITMASK (BITS_FOR_SECONDS) ) == 60) {
      00009F C6u00u02         [ 1]  209 	ld	a, _uptime+2
      0000A2 CEu00u00         [ 2]  210 	ldw	x, _uptime+0
      0000A5 54               [ 2]  211 	srlw	x
      0000A6 46               [ 1]  212 	rrc	a
      0000A7 54               [ 2]  213 	srlw	x
      0000A8 46               [ 1]  214 	rrc	a
      0000A9 A4 3F            [ 1]  215 	and	a, #0x3f
      0000AB 97               [ 1]  216 	ld	xl, a
      0000AC 4F               [ 1]  217 	clr	a
      0000AD 90 5F            [ 1]  218 	clrw	y
      0000AF 95               [ 1]  219 	ld	xh, a
      0000B0 A3 00 3C         [ 2]  220 	cpw	x, #0x003c
      0000B3 26 1F            [ 1]  221 	jrne	00102$
      0000B5 90 5D            [ 2]  222 	tnzw	y
      0000B7 26 1B            [ 1]  223 	jrne	00102$
                                    224 ;	./timer.c: 142: uptime &= NBITMASK (MINUTES_FIRST_BIT);
      0000B9 5F               [ 1]  225 	clrw	x
      0000BA 90 CEu00u00      [ 2]  226 	ldw	y, _uptime+0
      0000BE CFu00u02         [ 2]  227 	ldw	_uptime+2, x
      0000C1 90 CFu00u00      [ 2]  228 	ldw	_uptime+0, y
                                    229 ;	./timer.c: 143: uptime += (unsigned long) 1 << MINUTES_FIRST_BIT;
      0000C5 90 CEu00u02      [ 2]  230 	ldw	y, _uptime+2
      0000C9 CEu00u00         [ 2]  231 	ldw	x, _uptime+0
      0000CC 5C               [ 1]  232 	incw	x
      0000CD 90 CFu00u02      [ 2]  233 	ldw	_uptime+2, y
      0000D1 CFu00u00         [ 2]  234 	ldw	_uptime+0, x
      0000D4                        235 00102$:
                                    236 ;	./timer.c: 147: if ( ( (unsigned char) (uptime >> MINUTES_FIRST_BIT) & BITMASK (BITS_FOR_MINUTES) ) == 60) {
      0000D4 CEu00u00         [ 2]  237 	ldw	x, _uptime+0
      0000D7 9F               [ 1]  238 	ld	a, xl
      0000D8 A4 3F            [ 1]  239 	and	a, #0x3f
      0000DA 97               [ 1]  240 	ld	xl, a
      0000DB 4F               [ 1]  241 	clr	a
      0000DC 90 5F            [ 1]  242 	clrw	y
      0000DE 95               [ 1]  243 	ld	xh, a
      0000DF A3 00 3C         [ 2]  244 	cpw	x, #0x003c
      0000E2 26 26            [ 1]  245 	jrne	00104$
                                    246 ;	./timer.c: 148: uptime &= NBITMASK (HOURS_FIRST_BIT);
      0000E4 90 5D            [ 2]  247 	tnzw	y
      0000E6 26 22            [ 1]  248 	jrne	00104$
      0000E8 C6u00u01         [ 1]  249 	ld	a, _uptime+1
      0000EB A4 C0            [ 1]  250 	and	a, #0xc0
      0000ED 97               [ 1]  251 	ld	xl, a
      0000EE C6u00u00         [ 1]  252 	ld	a, _uptime+0
      0000F1 95               [ 1]  253 	ld	xh, a
      0000F2 90 CFu00u02      [ 2]  254 	ldw	_uptime+2, y
      0000F6 CFu00u00         [ 2]  255 	ldw	_uptime+0, x
                                    256 ;	./timer.c: 149: uptime += (unsigned long) 1 << HOURS_FIRST_BIT;
      0000F9 90 CEu00u02      [ 2]  257 	ldw	y, _uptime+2
      0000FD CEu00u00         [ 2]  258 	ldw	x, _uptime+0
      000100 1C 00 40         [ 2]  259 	addw	x, #0x0040
      000103 90 CFu00u02      [ 2]  260 	ldw	_uptime+2, y
      000107 CFu00u00         [ 2]  261 	ldw	_uptime+0, x
      00010A                        262 00104$:
                                    263 ;	./timer.c: 153: if ( ( (unsigned char) (uptime >> HOURS_FIRST_BIT) & BITMASK (BITS_FOR_HOURS) ) == 24) {
      00010A CEu00u00         [ 2]  264 	ldw	x, _uptime+0
      00010D A6 40            [ 1]  265 	ld	a, #0x40
      00010F 62               [ 2]  266 	div	x, a
      000110 9F               [ 1]  267 	ld	a, xl
      000111 A4 1F            [ 1]  268 	and	a, #0x1f
      000113 97               [ 1]  269 	ld	xl, a
      000114 4F               [ 1]  270 	clr	a
      000115 90 5F            [ 1]  271 	clrw	y
      000117 95               [ 1]  272 	ld	xh, a
      000118 A3 00 18         [ 2]  273 	cpw	x, #0x0018
      00011B 26 24            [ 1]  274 	jrne	00108$
                                    275 ;	./timer.c: 154: uptime &= NBITMASK (DAYS_FIRST_BIT);
      00011D 90 5D            [ 2]  276 	tnzw	y
      00011F 26 20            [ 1]  277 	jrne	00108$
      000121 4F               [ 1]  278 	clr	a
      000122 97               [ 1]  279 	ld	xl, a
      000123 C6u00u00         [ 1]  280 	ld	a, _uptime+0
      000126 A4 F8            [ 1]  281 	and	a, #0xf8
      000128 95               [ 1]  282 	ld	xh, a
      000129 90 CFu00u02      [ 2]  283 	ldw	_uptime+2, y
      00012D CFu00u00         [ 2]  284 	ldw	_uptime+0, x
                                    285 ;	./timer.c: 155: uptime += (unsigned long) 1 << DAYS_FIRST_BIT;
      000130 90 CEu00u02      [ 2]  286 	ldw	y, _uptime+2
      000134 CEu00u00         [ 2]  287 	ldw	x, _uptime+0
      000137 1C 08 00         [ 2]  288 	addw	x, #0x0800
      00013A 90 CFu00u02      [ 2]  289 	ldw	_uptime+2, y
      00013E CFu00u00         [ 2]  290 	ldw	_uptime+0, x
      000141                        291 00108$:
                                    292 ;	./timer.c: 159: uptime++;
      000141 CEu00u02         [ 2]  293 	ldw	x, _uptime+2
      000144 1C 00 01         [ 2]  294 	addw	x, #0x0001
      000147 90 CEu00u00      [ 2]  295 	ldw	y, _uptime+0
      00014B 24 02            [ 1]  296 	jrnc	00165$
      00014D 90 5C            [ 1]  297 	incw	y
      00014F                        298 00165$:
      00014F CFu00u02         [ 2]  299 	ldw	_uptime+2, x
      000152 90 CFu00u00      [ 2]  300 	ldw	_uptime+0, y
                                    301 ;	./timer.c: 162: if ( ( (unsigned char) getUptimeTicks() & 0x0F) == 1) {
      000156 CDr00r27         [ 4]  302 	call	_getUptimeTicks
      000159 9F               [ 1]  303 	ld	a, xl
      00015A A4 0F            [ 1]  304 	and	a, #0x0f
      00015C 97               [ 1]  305 	ld	xl, a
      00015D 4F               [ 1]  306 	clr	a
      00015E 95               [ 1]  307 	ld	xh, a
      00015F 5A               [ 2]  308 	decw	x
      000160 26 05            [ 1]  309 	jrne	00115$
                                    310 ;	./timer.c: 163: refreshMenu();
      000162 CDr00r00         [ 4]  311 	call	_refreshMenu
      000165 20 1C            [ 2]  312 	jra	00116$
      000167                        313 00115$:
                                    314 ;	./timer.c: 164: } else if ( ( (unsigned char) getUptimeTicks() & 0xFF) == 2) {
      000167 CDr00r27         [ 4]  315 	call	_getUptimeTicks
      00016A 4F               [ 1]  316 	clr	a
      00016B 95               [ 1]  317 	ld	xh, a
      00016C A3 00 02         [ 2]  318 	cpw	x, #0x0002
      00016F 26 05            [ 1]  319 	jrne	00112$
                                    320 ;	./timer.c: 165: startADC();
      000171 CDr00r00         [ 4]  321 	call	_startADC
      000174 20 0D            [ 2]  322 	jra	00116$
      000176                        323 00112$:
                                    324 ;	./timer.c: 166: } else if ( ( (unsigned char) getUptimeTicks() & 0xFF) == 3) {
      000176 CDr00r27         [ 4]  325 	call	_getUptimeTicks
      000179 4F               [ 1]  326 	clr	a
      00017A 95               [ 1]  327 	ld	xh, a
      00017B A3 00 03         [ 2]  328 	cpw	x, #0x0003
      00017E 26 03            [ 1]  329 	jrne	00116$
                                    330 ;	./timer.c: 167: refreshRelay();
      000180 CDr00r00         [ 4]  331 	call	_refreshRelay
      000183                        332 00116$:
                                    333 ;	./timer.c: 170: refreshDisplay();
      000183 CDr00r00         [ 4]  334 	call	_refreshDisplay
                                    335 ;	./timer.c: 171: }
      000186 80               [11]  336 	iret
                                    337 	.area CODE
                                    338 	.area CONST
                                    339 	.area INITIALIZER
                                    340 	.area CABS (ABS)
